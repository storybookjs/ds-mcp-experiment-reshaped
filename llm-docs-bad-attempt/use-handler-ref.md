# useHandlerRef Hook

## Overview
The useHandlerRef hook creates stable event handler references that don't change between renders while always calling the latest version of the handler function, preventing unnecessary re-renders and effect dependencies.

## Key Features
- Stable handler references
- Always calls latest handler version
- Prevents unnecessary re-renders
- Optimizes effect dependencies
- Memory efficient

## Hook Interface
```typescript
function useHandlerRef<T extends (...args: any[]) => any>(
  handler: T | undefined
): React.RefObject<T | undefined>;
```

## Usage Examples

### Basic Event Handler Stabilization
```typescript
import { useHandlerRef, Button, Text, View } from 'reshaped';\nimport { useState, useEffect } from 'react';\n\nfunction BasicHandlerExample() {\n  const [count, setCount] = useState(0);\n  const [message, setMessage] = useState('');\n  \n  // Handler that depends on count state\n  const handleClick = (increment: number) => {\n    setCount(prevCount => prevCount + increment);\n    setMessage(`Incremented by ${increment}`);\n  };\n  \n  // Stabilize the handler reference\n  const stableHandlerRef = useHandlerRef(handleClick);\n  \n  // This effect won't re-run when count changes\n  useEffect(() => {\n    const handleKeyPress = (event: KeyboardEvent) => {\n      if (event.key === ' ' && stableHandlerRef.current) {\n        event.preventDefault();\n        stableHandlerRef.current(1);\n      }\n    };\n    \n    window.addEventListener('keydown', handleKeyPress);\n    return () => window.removeEventListener('keydown', handleKeyPress);\n  }, [stableHandlerRef]); // Stable dependency\n  \n  return (\n    <View gap={4}>\n      <Text variant=\"title-5\">Count: {count}</Text>\n      <Text variant=\"body-3\" color=\"neutral-faded\">{message}</Text>\n      \n      <View direction=\"row\" gap={2}>\n        <Button onClick={() => stableHandlerRef.current?.(1)}>\n          +1\n        </Button>\n        <Button onClick={() => stableHandlerRef.current?.(5)}>\n          +5\n        </Button>\n        <Button onClick={() => stableHandlerRef.current?.(10)}>\n          +10\n        </Button>\n      </View>\n      \n      <Text variant=\"body-3\" color=\"neutral-faded\">\n        Press spacebar to increment by 1\n      </Text>\n    </View>\n  );\n}\n```\n\n### Optimized Component with Callbacks\n```typescript\nimport { useHandlerRef, Button, Text, View, Card } from 'reshaped';\nimport { useState, useCallback, memo } from 'react';\n\n// Child component that receives callbacks\nconst ExpensiveChild = memo(({ \n  onAction, \n  data \n}: { \n  onAction: (type: string, value: any) => void;\n  data: { name: string; value: number };\n}) => {\n  console.log('ExpensiveChild rendered'); // This should only log when data changes\n  \n  return (\n    <Card padding={4}>\n      <View gap={3}>\n        <Text variant=\"title-6\">{data.name}</Text>\n        <Text variant=\"body-3\">Value: {data.value}</Text>\n        <View direction=\"row\" gap={2}>\n          <Button size=\"small\" onClick={() => onAction('increment', data.value)}>\n            Increment\n          </Button>\n          <Button size=\"small\" onClick={() => onAction('decrement', data.value)}>\n            Decrement\n          </Button>\n          <Button size=\"small\" onClick={() => onAction('reset', 0)}>\n            Reset\n          </Button>\n        </View>\n      </View>\n    </Card>\n  );\n});\n\nfunction OptimizedParent() {\n  const [items, setItems] = useState([\n    { id: 1, name: 'Counter 1', value: 0 },\n    { id: 2, name: 'Counter 2', value: 0 },\n    { id: 3, name: 'Counter 3', value: 0 }\n  ]);\n  \n  const [logs, setLogs] = useState<string[]>([]);\n  \n  // Handler that updates items state\n  const handleAction = (id: number, type: string, value: any) => {\n    const timestamp = new Date().toLocaleTimeString();\n    setLogs(prev => [...prev.slice(-4), `${timestamp}: ${type} on item ${id}`]);\n    \n    setItems(prev => prev.map(item => \n      item.id === id \n        ? { ...item, value: type === 'reset' ? 0 : \n                          type === 'increment' ? item.value + 1 : \n                          Math.max(0, item.value - 1) }\n        : item\n    ));\n  };\n  \n  // Create stable handler ref\n  const stableHandlerRef = useHandlerRef(handleAction);\n  \n  // Create stable callback for each item\n  const createItemHandler = useCallback((id: number) => \n    (type: string, value: any) => stableHandlerRef.current?.(id, type, value),\n    [stableHandlerRef]\n  );\n  \n  return (\n    <View gap={6}>\n      <Text variant=\"title-4\">Optimized Handler Example</Text>\n      \n      <View gap={4}>\n        {items.map(item => (\n          <ExpensiveChild\n            key={item.id}\n            data={item}\n            onAction={createItemHandler(item.id)}\n          />\n        ))}\n      </View>\n      \n      <Card padding={4}>\n        <View gap={3}>\n          <Text variant=\"title-6\">Action Log</Text>\n          {logs.length === 0 ? (\n            <Text variant=\"body-3\" color=\"neutral-faded\">\n              No actions yet\n            </Text>\n          ) : (\n            logs.map((log, index) => (\n              <Text key={index} variant=\"body-3\" style={{ fontFamily: 'monospace' }}>\n                {log}\n              </Text>\n            ))\n          )}\n        </View>\n      </Card>\n    </View>\n  );\n}\n```\n\n### WebSocket with Stable Handlers\n```typescript\nimport { useHandlerRef, Text, View, Card, Button } from 'reshaped';\nimport { useState, useEffect, useRef } from 'react';\n\ntype Message = {\n  id: string;\n  text: string;\n  timestamp: Date;\n  type: 'sent' | 'received';\n};\n\nfunction WebSocketChat() {\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [connected, setConnected] = useState(false);\n  const [inputValue, setInputValue] = useState('');\n  const wsRef = useRef<WebSocket | null>(null);\n  \n  // Message handling functions\n  const handleMessage = (event: MessageEvent) => {\n    const message: Message = {\n      id: Date.now().toString(),\n      text: event.data,\n      timestamp: new Date(),\n      type: 'received'\n    };\n    setMessages(prev => [...prev, message]);\n  };\n  \n  const handleOpen = () => {\n    setConnected(true);\n    console.log('WebSocket connected');\n  };\n  \n  const handleClose = () => {\n    setConnected(false);\n    console.log('WebSocket disconnected');\n  };\n  \n  const handleError = (error: Event) => {\n    console.error('WebSocket error:', error);\n    setConnected(false);\n  };\n  \n  // Create stable handler references\n  const stableMessageHandler = useHandlerRef(handleMessage);\n  const stableOpenHandler = useHandlerRef(handleOpen);\n  const stableCloseHandler = useHandlerRef(handleClose);\n  const stableErrorHandler = useHandlerRef(handleError);\n  \n  // WebSocket effect with stable dependencies\n  useEffect(() => {\n    const ws = new WebSocket('wss://echo.websocket.org');\n    wsRef.current = ws;\n    \n    ws.onmessage = (event) => stableMessageHandler.current?.(event);\n    ws.onopen = (event) => stableOpenHandler.current?.(event);\n    ws.onclose = (event) => stableCloseHandler.current?.(event);\n    ws.onerror = (event) => stableErrorHandler.current?.(event);\n    \n    return () => {\n      ws.close();\n      wsRef.current = null;\n    };\n  }, [stableMessageHandler, stableOpenHandler, stableCloseHandler, stableErrorHandler]);\n  \n  const sendMessage = () => {\n    if (wsRef.current && connected && inputValue.trim()) {\n      const message: Message = {\n        id: Date.now().toString(),\n        text: inputValue,\n        timestamp: new Date(),\n        type: 'sent'\n      };\n      \n      wsRef.current.send(inputValue);\n      setMessages(prev => [...prev, message]);\n      setInputValue('');\n    }\n  };\n  \n  return (\n    <View gap={4}>\n      <View direction=\"row\" justify=\"space-between\" align=\"center\">\n        <Text variant=\"title-5\">WebSocket Chat</Text>\n        <Text \n          variant=\"body-3\" \n          color={connected ? 'positive' : 'critical'}\n        >\n          {connected ? '● Connected' : '● Disconnected'}\n        </Text>\n      </View>\n      \n      <Card padding={4} maxHeight={300} style={{ overflow: 'auto' }}>\n        <View gap={2}>\n          {messages.length === 0 ? (\n            <Text variant=\"body-3\" color=\"neutral-faded\" align=\"center\">\n              No messages yet\n            </Text>\n          ) : (\n            messages.map(message => (\n              <View \n                key={message.id}\n                align={message.type === 'sent' ? 'end' : 'start'}\n              >\n                <div\n                  style={{\n                    maxWidth: '70%',\n                    padding: '8px 12px',\n                    borderRadius: '12px',\n                    backgroundColor: message.type === 'sent' \n                      ? 'var(--rs-color-background-primary)' \n                      : 'var(--rs-color-background-neutral-faded)',\n                    color: message.type === 'sent' \n                      ? 'var(--rs-color-foreground-primary-contrast)' \n                      : 'var(--rs-color-foreground-neutral)'\n                  }}\n                >\n                  <Text variant=\"body-3\">{message.text}</Text>\n                  <Text \n                    variant=\"caption\" \n                    style={{ \n                      opacity: 0.7,\n                      fontSize: '11px',\n                      marginTop: '4px' \n                    }}\n                  >\n                    {message.timestamp.toLocaleTimeString()}\n                  </Text>\n                </div>\n              </View>\n            ))\n          )}\n        </View>\n      </Card>\n      \n      <View direction=\"row\" gap={2}>\n        <input\n          type=\"text\"\n          value={inputValue}\n          onChange={(e) => setInputValue(e.target.value)}\n          onKeyPress={(e) => e.key === 'Enter' && sendMessage()}\n          placeholder=\"Type a message...\"\n          disabled={!connected}\n          style={{\n            flex: 1,\n            padding: '8px 12px',\n            border: '1px solid var(--rs-color-border-neutral-faded)',\n            borderRadius: '6px'\n          }}\n        />\n        <Button \n          onClick={sendMessage}\n          disabled={!connected || !inputValue.trim()}\n        >\n          Send\n        </Button>\n      </View>\n    </View>\n  );\n}\n```\n\n### Custom Hook with Stable Handlers\n```typescript\nimport { useHandlerRef } from 'reshaped';\nimport { useEffect, useState } from 'react';\n\n// Custom hook that uses stable handlers internally\nfunction useAsyncOperation<T>(\n  operation: () => Promise<T>,\n  onSuccess?: (result: T) => void,\n  onError?: (error: Error) => void\n) {\n  const [loading, setLoading] = useState(false);\n  const [result, setResult] = useState<T | null>(null);\n  const [error, setError] = useState<Error | null>(null);\n  \n  // Create stable handler references\n  const stableOnSuccess = useHandlerRef(onSuccess);\n  const stableOnError = useHandlerRef(onError);\n  \n  const execute = async () => {\n    setLoading(true);\n    setError(null);\n    \n    try {\n      const result = await operation();\n      setResult(result);\n      stableOnSuccess.current?.(result);\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error('Unknown error');\n      setError(error);\n      stableOnError.current?.(error);\n    } finally {\n      setLoading(false);\n    }\n  };\n  \n  return {\n    execute,\n    loading,\n    result,\n    error,\n    reset: () => {\n      setResult(null);\n      setError(null);\n      setLoading(false);\n    }\n  };\n}\n\n// Usage example\nfunction AsyncOperationExample() {\n  const [successCount, setSuccessCount] = useState(0);\n  const [errorCount, setErrorCount] = useState(0);\n  \n  const operation = async () => {\n    // Simulate async operation\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    if (Math.random() > 0.7) {\n      throw new Error('Random failure');\n    }\n    return { data: 'Success result', timestamp: Date.now() };\n  };\n  \n  const { execute, loading, result, error, reset } = useAsyncOperation(\n    operation,\n    (result) => {\n      console.log('Success:', result);\n      setSuccessCount(prev => prev + 1);\n    },\n    (error) => {\n      console.error('Error:', error);\n      setErrorCount(prev => prev + 1);\n    }\n  );\n  \n  return (\n    <View gap={4}>\n      <Text variant=\"title-5\">Async Operation</Text>\n      \n      <View direction=\"row\" gap={2}>\n        <Text variant=\"body-3\">Successes: {successCount}</Text>\n        <Text variant=\"body-3\">Errors: {errorCount}</Text>\n      </View>\n      \n      {result && (\n        <Card padding={3}>\n          <Text variant=\"body-3\" color=\"positive\">\n            Success: {JSON.stringify(result)}\n          </Text>\n        </Card>\n      )}\n      \n      {error && (\n        <Card padding={3}>\n          <Text variant=\"body-3\" color=\"critical\">\n            Error: {error.message}\n          </Text>\n        </Card>\n      )}\n      \n      <View direction=\"row\" gap={2}>\n        <Button onClick={execute} disabled={loading}>\n          {loading ? 'Loading...' : 'Execute'}\n        </Button>\n        <Button onClick={reset} variant=\"outline\">\n          Reset\n        </Button>\n      </View>\n    </View>\n  );\n}\n```\n\n## Benefits\n\n### Performance Optimization\n- Prevents unnecessary component re-renders\n- Stable references for effect dependencies\n- Reduces memory allocations\n- Optimizes memoization effectiveness\n\n### Use Cases\n- Event handlers in effects\n- Callback props to memoized components\n- WebSocket event handlers\n- Timer and interval callbacks\n- Custom hooks with callback parameters\n\n## Best Practices\n- Always use `.current` to access the handler\n- Check for existence before calling (optional chaining)\n- Use in effect dependencies for stable references\n- Combine with useCallback for component callback props\n- Prefer this over useCallback for effect dependencies\n\n## Related Hooks\n- **useCallback**: For memoizing callback functions\n- **useMemo**: For memoizing computed values\n- **useEffect**: Where stable handler refs are most useful"