# useIsomorphicLayoutEffect Hook

## Overview
The useIsomorphicLayoutEffect hook is a cross-platform hook that uses useLayoutEffect on the client and useEffect on the server, preventing hydration mismatches in server-side rendered applications.

## Key Features
- Server-side rendering compatibility
- Prevents hydration warnings
- Synchronous DOM updates on client
- Fallback to useEffect on server
- TypeScript-safe implementation

## Hook Interface
```typescript
function useIsomorphicLayoutEffect(\n  effect: React.EffectCallback,\n  deps?: React.DependencyList\n): void;\n```\n\n## Usage Examples\n\n### DOM Measurements\n```typescript\nimport { useIsomorphicLayoutEffect, Text, View, Card } from 'reshaped';\nimport { useState, useRef } from 'react';\n\nfunction DOMSizeTracker() {\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });\n  const [resizeCount, setResizeCount] = useState(0);\n  const containerRef = useRef<HTMLDivElement>(null);\n  \n  // Measure DOM element dimensions synchronously\n  useIsomorphicLayoutEffect(() => {\n    const updateDimensions = () => {\n      if (containerRef.current) {\n        const { offsetWidth, offsetHeight } = containerRef.current;\n        setDimensions(prev => {\n          if (prev.width !== offsetWidth || prev.height !== offsetHeight) {\n            setResizeCount(count => count + 1);\n            return { width: offsetWidth, height: offsetHeight };\n          }\n          return prev;\n        });\n      }\n    };\n    \n    // Initial measurement\n    updateDimensions();\n    \n    // Listen for window resize\n    const handleResize = () => {\n      // Use setTimeout to debounce resize events\n      setTimeout(updateDimensions, 0);\n    };\n    \n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n  \n  return (\n    <Card padding={6}>\n      <View gap={4}>\n        <Text variant=\"title-5\">DOM Size Tracker</Text>\n        \n        <div \n          ref={containerRef}\n          style={{ \n            minHeight: '100px',\n            background: 'linear-gradient(45deg, #f0f0f0, #e0e0e0)',\n            borderRadius: '8px',\n            padding: '16px',\n            resize: 'both',\n            overflow: 'auto'\n          }}\n        >\n          <View gap={2}>\n            <Text variant=\"body-2\">\n              This container can be resized by dragging the bottom-right corner.\n            </Text>\n            \n            <Text variant=\"body-3\">\n              Width: {dimensions.width}px\n            </Text>\n            \n            <Text variant=\"body-3\">\n              Height: {dimensions.height}px\n            </Text>\n            \n            <Text variant=\"body-3\" color=\"neutral-faded\">\n              Resize count: {resizeCount}\n            </Text>\n          </View>\n        </div>\n        \n        <Text variant=\"body-3\" color=\"neutral-faded\">\n          useIsomorphicLayoutEffect ensures measurements happen synchronously \n          after DOM updates, preventing layout shifts.\n        </Text>\n      </View>\n    </Card>\n  );\n}\n```\n\n### Scroll Position Restoration\n```typescript\nimport { useIsomorphicLayoutEffect, Text, View, Card, Button } from 'reshaped';\nimport { useState, useRef, useCallback } from 'react';\n\nfunction ScrollPositionRestoration() {\n  const [items] = useState(Array.from({ length: 50 }, (_, i) => `Item ${i + 1}`));\n  const [savedPosition, setSavedPosition] = useState(0);\n  const [currentPosition, setCurrentPosition] = useState(0);\n  const scrollContainerRef = useRef<HTMLDivElement>(null);\n  \n  // Save scroll position\n  const savePosition = useCallback(() => {\n    if (scrollContainerRef.current) {\n      const position = scrollContainerRef.current.scrollTop;\n      setSavedPosition(position);\n      localStorage.setItem('scrollPosition', position.toString());\n    }\n  }, []);\n  \n  // Restore scroll position on mount/navigation\n  useIsomorphicLayoutEffect(() => {\n    const container = scrollContainerRef.current;\n    if (!container) return;\n    \n    // Get saved position from localStorage\n    const savedPos = localStorage.getItem('scrollPosition');\n    if (savedPos) {\n      const position = parseInt(savedPos, 10);\n      // Restore synchronously to prevent flash\n      container.scrollTop = position;\n      setCurrentPosition(position);\n    }\n    \n    // Track scroll position changes\n    const handleScroll = () => {\n      setCurrentPosition(container.scrollTop);\n    };\n    \n    container.addEventListener('scroll', handleScroll, { passive: true });\n    return () => container.removeEventListener('scroll', handleScroll);\n  }, []);\n  \n  const scrollToTop = () => {\n    scrollContainerRef.current?.scrollTo({ top: 0, behavior: 'smooth' });\n  };\n  \n  const scrollToBottom = () => {\n    if (scrollContainerRef.current) {\n      scrollContainerRef.current.scrollTo({ \n        top: scrollContainerRef.current.scrollHeight, \n        behavior: 'smooth' \n      });\n    }\n  };\n  \n  return (\n    <View gap={4}>\n      <Card padding={4}>\n        <View gap={3}>\n          <Text variant=\"title-5\">Scroll Position Restoration</Text>\n          \n          <View direction=\"row\" gap={2}>\n            <Button size=\"small\" onClick={savePosition}>\n              Save Position\n            </Button>\n            <Button size=\"small\" onClick={scrollToTop}>\n              Top\n            </Button>\n            <Button size=\"small\" onClick={scrollToBottom}>\n              Bottom\n            </Button>\n          </View>\n          \n          <View direction=\"row\" gap={4}>\n            <Text variant=\"body-3\">\n              Current: {Math.round(currentPosition)}px\n            </Text>\n            <Text variant=\"body-3\">\n              Saved: {savedPosition}px\n            </Text>\n          </View>\n        </View>\n      </Card>\n      \n      <Card \n        ref={scrollContainerRef}\n        padding={4}\n        style={{ \n          height: '300px',\n          overflow: 'auto',\n          border: '1px solid var(--rs-color-border-neutral-faded)'\n        }}\n      >\n        <View gap={2}>\n          {items.map((item) => (\n            <div\n              key={item}\n              style={{\n                padding: '12px',\n                backgroundColor: 'var(--rs-color-background-neutral-faded)',\n                borderRadius: '6px'\n              }}\n            >\n              <Text variant=\"body-3\">{item}</Text>\n            </div>\n          ))}\n        </View>\n      </Card>\n      \n      <Text variant=\"body-3\" color=\"neutral-faded\">\n        Scroll position is restored synchronously on page load using \n        useIsomorphicLayoutEffect to prevent scrolling jumps.\n      </Text>\n    </View>\n  );\n}\n```\n\n### Theme Class Application\n```typescript\nimport { useIsomorphicLayoutEffect, Text, View, Card, Button } from 'reshaped';\nimport { useState } from 'react';\n\nfunction ThemeClassManager() {\n  const [theme, setTheme] = useState<'light' | 'dark' | 'auto'>('light');\n  const [appliedTheme, setAppliedTheme] = useState<'light' | 'dark'>('light');\n  \n  // Apply theme classes to document element synchronously\n  useIsomorphicLayoutEffect(() => {\n    const applyTheme = () => {\n      const html = document.documentElement;\n      \n      let resolvedTheme: 'light' | 'dark';\n      \n      if (theme === 'auto') {\n        // Detect system preference\n        resolvedTheme = window.matchMedia('(prefers-color-scheme: dark)').matches \n          ? 'dark' \n          : 'light';\n      } else {\n        resolvedTheme = theme;\n      }\n      \n      // Apply theme class synchronously to prevent flash\n      html.classList.remove('theme-light', 'theme-dark');\n      html.classList.add(`theme-${resolvedTheme}`);\n      \n      // Update CSS custom properties\n      html.style.setProperty(\n        '--app-background', \n        resolvedTheme === 'dark' ? '#1a1a1a' : '#ffffff'\n      );\n      html.style.setProperty(\n        '--app-foreground', \n        resolvedTheme === 'dark' ? '#ffffff' : '#000000'\n      );\n      \n      setAppliedTheme(resolvedTheme);\n    };\n    \n    applyTheme();\n    \n    // Listen for system theme changes when in auto mode\n    if (theme === 'auto') {\n      const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');\n      const handleChange = () => applyTheme();\n      \n      mediaQuery.addEventListener('change', handleChange);\n      return () => mediaQuery.removeEventListener('change', handleChange);\n    }\n  }, [theme]);\n  \n  return (\n    <Card padding={6}>\n      <View gap={4}>\n        <Text variant=\"title-5\">Theme Class Manager</Text>\n        \n        <Text variant=\"body-3\">\n          Current theme: <Text as=\"span\" weight=\"medium\">{theme}</Text>\n          {theme === 'auto' && (\n            <Text as=\"span\" color=\"neutral-faded\"> (resolved to {appliedTheme})</Text>\n          )}\n        </Text>\n        \n        <View direction=\"row\" gap={2}>\n          <Button \n            size=\"small\"\n            variant={theme === 'light' ? 'solid' : 'outline'}\n            onClick={() => setTheme('light')}\n          >\n            Light\n          </Button>\n          <Button \n            size=\"small\"\n            variant={theme === 'dark' ? 'solid' : 'outline'}\n            onClick={() => setTheme('dark')}\n          >\n            Dark\n          </Button>\n          <Button \n            size=\"small\"\n            variant={theme === 'auto' ? 'solid' : 'outline'}\n            onClick={() => setTheme('auto')}\n          >\n            Auto\n          </Button>\n        </View>\n        \n        <View \n          padding={4}\n          style={{\n            backgroundColor: 'var(--app-background)',\n            color: 'var(--app-foreground)',\n            border: '2px solid var(--rs-color-border-neutral-faded)',\n            borderRadius: '8px',\n            transition: 'background-color 0.2s, color 0.2s'\n          }}\n        >\n          <Text variant=\"body-3\">\n            This area uses CSS custom properties set by useIsomorphicLayoutEffect.\n            The theme is applied synchronously to prevent visual flashing.\n          </Text>\n        </View>\n        \n        <Text variant=\"body-3\" color=\"neutral-faded\">\n          useIsomorphicLayoutEffect ensures theme classes are applied \n          before the browser paints, eliminating the flash of incorrect theme.\n        </Text>\n      </View>\n    </Card>\n  );\n}\n```\n\n### Focus Management\n```typescript\nimport { useIsomorphicLayoutEffect, Text, View, Card, Button, TextField } from 'reshaped';\nimport { useState, useRef } from 'react';\n\nfunction FocusManager() {\n  const [step, setStep] = useState(1);\n  const [formData, setFormData] = useState({ name: '', email: '', message: '' });\n  const nameRef = useRef<HTMLInputElement>(null);\n  const emailRef = useRef<HTMLInputElement>(null);\n  const messageRef = useRef<HTMLTextAreaElement>(null);\n  const submitRef = useRef<HTMLButtonElement>(null);\n  \n  // Focus management for multi-step form\n  useIsomorphicLayoutEffect(() => {\n    // Focus appropriate element based on current step\n    switch (step) {\n      case 1:\n        nameRef.current?.focus();\n        break;\n      case 2:\n        emailRef.current?.focus();\n        break;\n      case 3:\n        messageRef.current?.focus();\n        break;\n      case 4:\n        submitRef.current?.focus();\n        break;\n    }\n  }, [step]);\n  \n  const nextStep = () => {\n    if (step < 4) setStep(step + 1);\n  };\n  \n  const prevStep = () => {\n    if (step > 1) setStep(step - 1);\n  };\n  \n  const resetForm = () => {\n    setStep(1);\n    setFormData({ name: '', email: '', message: '' });\n  };\n  \n  return (\n    <Card padding={6}>\n      <View gap={6}>\n        <View gap={2}>\n          <Text variant=\"title-5\">Multi-Step Form with Focus Management</Text>\n          <Text variant=\"body-3\" color=\"neutral-faded\">\n            Step {step} of 4\n          </Text>\n        </View>\n        \n        <View gap={4}>\n          {step === 1 && (\n            <View gap={3}>\n              <Text variant=\"title-6\">Step 1: Your Name</Text>\n              <TextField\n                ref={nameRef}\n                value={formData.name}\n                onChange={(name) => setFormData(prev => ({ ...prev, name }))}\n                placeholder=\"Enter your full name\"\n                onKeyPress={(e) => e.key === 'Enter' && nextStep()}\n              />\n            </View>\n          )}\n          \n          {step === 2 && (\n            <View gap={3}>\n              <Text variant=\"title-6\">Step 2: Your Email</Text>\n              <TextField\n                ref={emailRef}\n                type=\"email\"\n                value={formData.email}\n                onChange={(email) => setFormData(prev => ({ ...prev, email }))}\n                placeholder=\"Enter your email address\"\n                onKeyPress={(e) => e.key === 'Enter' && nextStep()}\n              />\n            </View>\n          )}\n          \n          {step === 3 && (\n            <View gap={3}>\n              <Text variant=\"title-6\">Step 3: Your Message</Text>\n              <textarea\n                ref={messageRef}\n                value={formData.message}\n                onChange={(e) => setFormData(prev => ({ ...prev, message: e.target.value }))}\n                placeholder=\"Enter your message\"\n                rows={4}\n                style={{\n                  width: '100%',\n                  padding: '8px 12px',\n                  border: '1px solid var(--rs-color-border-neutral-faded)',\n                  borderRadius: '6px',\n                  resize: 'vertical'\n                }}\n              />\n            </View>\n          )}\n          \n          {step === 4 && (\n            <View gap={3}>\n              <Text variant=\"title-6\">Step 4: Review & Submit</Text>\n              <View gap={2}>\n                <Text variant=\"body-3\">\n                  <Text as=\"span\" weight=\"medium\">Name:</Text> {formData.name || 'Not provided'}\n                </Text>\n                <Text variant=\"body-3\">\n                  <Text as=\"span\" weight=\"medium\">Email:</Text> {formData.email || 'Not provided'}\n                </Text>\n                <Text variant=\"body-3\">\n                  <Text as=\"span\" weight=\"medium\">Message:</Text> {formData.message || 'Not provided'}\n                </Text>\n              </View>\n            </View>\n          )}\n        </View>\n        \n        <View direction=\"row\" justify=\"space-between\">\n          <Button \n            variant=\"outline\" \n            onClick={prevStep}\n            disabled={step === 1}\n          >\n            Previous\n          </Button>\n          \n          <View direction=\"row\" gap={2}>\n            <Button variant=\"ghost\" onClick={resetForm}>\n              Reset\n            </Button>\n            \n            {step < 4 ? (\n              <Button onClick={nextStep}>\n                Next\n              </Button>\n            ) : (\n              <Button \n                ref={submitRef}\n                onClick={() => alert('Form submitted!')}\n              >\n                Submit\n              </Button>\n            )}\n          </View>\n        </View>\n        \n        <Text variant=\"body-3\" color=\"neutral-faded\">\n          Focus is automatically managed using useIsomorphicLayoutEffect, \n          ensuring the correct field is focused when stepping through the form.\n        </Text>\n      </View>\n    </Card>\n  );\n}\n```\n\n## When to Use\n\n### Perfect Use Cases\n- DOM measurements and calculations\n- Theme class application\n- Focus management\n- Scroll position restoration\n- Layout-critical updates\n- Preventing visual flashing\n\n### Avoid When\n- Data fetching or async operations\n- Side effects that don't affect layout\n- Non-critical DOM updates\n- Effects that should run after paint\n\n## SSR Considerations\n- Automatically falls back to useEffect on server\n- Prevents hydration mismatches\n- Safe for Next.js and other SSR frameworks\n- No console warnings about useLayoutEffect on server\n\n## Performance Impact\n- Runs synchronously before browser paint\n- Can block rendering if used excessively\n- Use sparingly for layout-critical operations\n- Consider useEffect for non-critical updates\n\n## Best Practices\n- Use for DOM measurements and layout updates\n- Avoid expensive computations in the effect\n- Keep dependency array minimal and stable\n- Prefer useEffect for non-layout-critical effects\n- Always check for client-side environment when needed\n\n## Related Hooks\n- **useEffect**: For non-layout-critical side effects\n- **useLayoutEffect**: Client-only synchronous effects"